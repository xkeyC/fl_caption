// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1363425016;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__whisper__cancel_cancellation_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    token_id: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cancel_cancellation_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_token_id = token_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::whisper::cancel_cancellation_token(api_token_id);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__text_util__count_duplicate_characters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    input: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "count_duplicate_characters",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_input = input.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::text_util::count_duplicate_characters(api_input).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__whisper__create_cancellation_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_cancellation_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::whisper::create_cancellation_token())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__whisper__launch_caption_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    whisper_client: impl CstDecode<crate::api::whisper::WhisperClient>,
    stream_sink: impl CstDecode<
        StreamSink<
            Vec<crate::whisper_caption::whisper::Segment>,
            flutter_rust_bridge::for_generated::DcoCodec,
        >,
    >,
    audio_device: impl CstDecode<Option<String>>,
    audio_device_is_input: impl CstDecode<Option<bool>>,
    audio_language: impl CstDecode<Option<String>>,
    cancel_token_id: impl CstDecode<String>,
    with_timestamps: impl CstDecode<Option<bool>>,
    verbose: impl CstDecode<Option<bool>>,
    try_with_cuda: impl CstDecode<Option<bool>>,
    whisper_max_audio_duration: impl CstDecode<Option<u32>>,
    inference_interval: impl CstDecode<Option<u64>>,
    whisper_default_max_decode_tokens: impl CstDecode<Option<usize>>,
    whisper_temperature: impl CstDecode<Option<f32>>,
    vad_model_path: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "launch_caption",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_whisper_client = whisper_client.cst_decode();
            let api_stream_sink = stream_sink.cst_decode();
            let api_audio_device = audio_device.cst_decode();
            let api_audio_device_is_input = audio_device_is_input.cst_decode();
            let api_audio_language = audio_language.cst_decode();
            let api_cancel_token_id = cancel_token_id.cst_decode();
            let api_with_timestamps = with_timestamps.cst_decode();
            let api_verbose = verbose.cst_decode();
            let api_try_with_cuda = try_with_cuda.cst_decode();
            let api_whisper_max_audio_duration = whisper_max_audio_duration.cst_decode();
            let api_inference_interval = inference_interval.cst_decode();
            let api_whisper_default_max_decode_tokens =
                whisper_default_max_decode_tokens.cst_decode();
            let api_whisper_temperature = whisper_temperature.cst_decode();
            let api_vad_model_path = vad_model_path.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::whisper::launch_caption(
                            api_whisper_client,
                            api_stream_sink,
                            api_audio_device,
                            api_audio_device_is_input,
                            api_audio_language,
                            api_cancel_token_id,
                            api_with_timestamps,
                            api_verbose,
                            api_try_with_cuda,
                            api_whisper_max_audio_duration,
                            api_inference_interval,
                            api_whisper_default_max_decode_tokens,
                            api_whisper_temperature,
                            api_vad_model_path,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__whisper__whisper_client_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    whisper_model: impl CstDecode<String>,
    whisper_config: impl CstDecode<String>,
    whisper_tokenizer: impl CstDecode<Vec<u8>>,
    is_multilingual: impl CstDecode<bool>,
    is_quantized: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "whisper_client_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_whisper_model = whisper_model.cst_decode();
            let api_whisper_config = whisper_config.cst_decode();
            let api_whisper_tokenizer = whisper_tokenizer.cst_decode();
            let api_is_multilingual = is_multilingual.cst_decode();
            let api_is_quantized = is_quantized.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::whisper::WhisperClient::new(
                        api_whisper_model,
                        api_whisper_config,
                        api_whisper_tokenizer,
                        api_is_multilingual,
                        api_is_quantized,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<f32> for f32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f32 {
        self
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl CstDecode<crate::whisper_caption::whisper::WhisperStatus> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::whisper_caption::whisper::WhisperStatus {
        match self {
            0 => crate::whisper_caption::whisper::WhisperStatus::Loading,
            1 => crate::whisper_caption::whisper::WhisperStatus::Ready,
            2 => crate::whisper_caption::whisper::WhisperStatus::Error,
            3 => crate::whisper_caption::whisper::WhisperStatus::Working,
            4 => crate::whisper_caption::whisper::WhisperStatus::Exit,
            _ => unreachable!("Invalid variant for WhisperStatus: {}", self),
        }
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode
    for StreamSink<
        Vec<crate::whisper_caption::whisper::Segment>,
        flutter_rust_bridge::for_generated::DcoCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return inner.parse().unwrap();
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::whisper_caption::whisper::DecodingResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tokens = <Vec<u32>>::sse_decode(deserializer);
        let mut var_text = <String>::sse_decode(deserializer);
        let mut var_avgLogprob = <f64>::sse_decode(deserializer);
        let mut var_noSpeechProb = <f64>::sse_decode(deserializer);
        let mut var_temperature = <f64>::sse_decode(deserializer);
        let mut var_compressionRatio = <f64>::sse_decode(deserializer);
        return crate::whisper_caption::whisper::DecodingResult {
            tokens: var_tokens,
            text: var_text,
            avg_logprob: var_avgLogprob,
            no_speech_prob: var_noSpeechProb,
            temperature: var_temperature,
            compression_ratio: var_compressionRatio,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::whisper_caption::whisper::Segment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::whisper_caption::whisper::Segment>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u128>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<usize>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::whisper_caption::whisper::Segment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_start = <f64>::sse_decode(deserializer);
        let mut var_duration = <f64>::sse_decode(deserializer);
        let mut var_dr =
            <crate::whisper_caption::whisper::DecodingResult>::sse_decode(deserializer);
        let mut var_reasoningDuration = <Option<u128>>::sse_decode(deserializer);
        let mut var_reasoningLang = <Option<String>>::sse_decode(deserializer);
        let mut var_audioDuration = <Option<u128>>::sse_decode(deserializer);
        let mut var_status =
            <crate::whisper_caption::whisper::WhisperStatus>::sse_decode(deserializer);
        return crate::whisper_caption::whisper::Segment {
            start: var_start,
            duration: var_duration,
            dr: var_dr,
            reasoning_duration: var_reasoningDuration,
            reasoning_lang: var_reasoningLang,
            audio_duration: var_audioDuration,
            status: var_status,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::whisper::WhisperClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_whisperModel = <String>::sse_decode(deserializer);
        let mut var_whisperConfig = <String>::sse_decode(deserializer);
        let mut var_whisperTokenizer = <Vec<u8>>::sse_decode(deserializer);
        let mut var_isMultilingual = <bool>::sse_decode(deserializer);
        let mut var_isQuantized = <bool>::sse_decode(deserializer);
        return crate::api::whisper::WhisperClient {
            whisper_model: var_whisperModel,
            whisper_config: var_whisperConfig,
            whisper_tokenizer: var_whisperTokenizer,
            is_multilingual: var_isMultilingual,
            is_quantized: var_isQuantized,
        };
    }
}

impl SseDecode for crate::whisper_caption::whisper::WhisperStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::whisper_caption::whisper::WhisperStatus::Loading,
            1 => crate::whisper_caption::whisper::WhisperStatus::Ready,
            2 => crate::whisper_caption::whisper::WhisperStatus::Error,
            3 => crate::whisper_caption::whisper::WhisperStatus::Working,
            4 => crate::whisper_caption::whisper::WhisperStatus::Exit,
            _ => unreachable!("Invalid variant for WhisperStatus: {}", inner),
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::whisper_caption::whisper::DecodingResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.tokens.into_into_dart().into_dart(),
            self.text.into_into_dart().into_dart(),
            self.avg_logprob.into_into_dart().into_dart(),
            self.no_speech_prob.into_into_dart().into_dart(),
            self.temperature.into_into_dart().into_dart(),
            self.compression_ratio.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::whisper_caption::whisper::DecodingResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::whisper_caption::whisper::DecodingResult>
    for crate::whisper_caption::whisper::DecodingResult
{
    fn into_into_dart(self) -> crate::whisper_caption::whisper::DecodingResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::whisper_caption::whisper::Segment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.start.into_into_dart().into_dart(),
            self.duration.into_into_dart().into_dart(),
            self.dr.into_into_dart().into_dart(),
            self.reasoning_duration.into_into_dart().into_dart(),
            self.reasoning_lang.into_into_dart().into_dart(),
            self.audio_duration.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::whisper_caption::whisper::Segment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::whisper_caption::whisper::Segment>
    for crate::whisper_caption::whisper::Segment
{
    fn into_into_dart(self) -> crate::whisper_caption::whisper::Segment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::whisper::WhisperClient {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.whisper_model.into_into_dart().into_dart(),
            self.whisper_config.into_into_dart().into_dart(),
            self.whisper_tokenizer.into_into_dart().into_dart(),
            self.is_multilingual.into_into_dart().into_dart(),
            self.is_quantized.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::whisper::WhisperClient
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::whisper::WhisperClient>
    for crate::api::whisper::WhisperClient
{
    fn into_into_dart(self) -> crate::api::whisper::WhisperClient {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::whisper_caption::whisper::WhisperStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Loading => 0.into_dart(),
            Self::Ready => 1.into_dart(),
            Self::Error => 2.into_dart(),
            Self::Working => 3.into_dart(),
            Self::Exit => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::whisper_caption::whisper::WhisperStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::whisper_caption::whisper::WhisperStatus>
    for crate::whisper_caption::whisper::WhisperStatus
{
    fn into_into_dart(self) -> crate::whisper_caption::whisper::WhisperStatus {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode
    for StreamSink<
        Vec<crate::whisper_caption::whisper::Segment>,
        flutter_rust_bridge::for_generated::DcoCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.to_string(), serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::whisper_caption::whisper::DecodingResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u32>>::sse_encode(self.tokens, serializer);
        <String>::sse_encode(self.text, serializer);
        <f64>::sse_encode(self.avg_logprob, serializer);
        <f64>::sse_encode(self.no_speech_prob, serializer);
        <f64>::sse_encode(self.temperature, serializer);
        <f64>::sse_encode(self.compression_ratio, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::whisper_caption::whisper::Segment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::whisper_caption::whisper::Segment>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u128>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <usize>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::whisper_caption::whisper::Segment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.start, serializer);
        <f64>::sse_encode(self.duration, serializer);
        <crate::whisper_caption::whisper::DecodingResult>::sse_encode(self.dr, serializer);
        <Option<u128>>::sse_encode(self.reasoning_duration, serializer);
        <Option<String>>::sse_encode(self.reasoning_lang, serializer);
        <Option<u128>>::sse_encode(self.audio_duration, serializer);
        <crate::whisper_caption::whisper::WhisperStatus>::sse_encode(self.status, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::whisper::WhisperClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.whisper_model, serializer);
        <String>::sse_encode(self.whisper_config, serializer);
        <Vec<u8>>::sse_encode(self.whisper_tokenizer, serializer);
        <bool>::sse_encode(self.is_multilingual, serializer);
        <bool>::sse_encode(self.is_quantized, serializer);
    }
}

impl SseEncode for crate::whisper_caption::whisper::WhisperStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::whisper_caption::whisper::WhisperStatus::Loading => 0,
                crate::whisper_caption::whisper::WhisperStatus::Ready => 1,
                crate::whisper_caption::whisper::WhisperStatus::Error => 2,
                crate::whisper_caption::whisper::WhisperStatus::Working => 3,
                crate::whisper_caption::whisper::WhisperStatus::Exit => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl
        CstDecode<
            StreamSink<
                Vec<crate::whisper_caption::whisper::Segment>,
                flutter_rust_bridge::for_generated::DcoCodec,
            >,
        > for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> StreamSink<
            Vec<crate::whisper_caption::whisper::Segment>,
            flutter_rust_bridge::for_generated::DcoCodec,
        > {
            let raw: String = self.cst_decode();
            StreamSink::deserialize(raw)
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<u128> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u128 {
            CstDecode::<String>::cst_decode(self).parse().unwrap()
        }
    }
    impl CstDecode<bool> for *mut bool {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<f32> for *mut f32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<usize> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::whisper::WhisperClient> for *mut wire_cst_whisper_client {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::whisper::WhisperClient {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::whisper::WhisperClient>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::whisper_caption::whisper::DecodingResult> for wire_cst_decoding_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::whisper_caption::whisper::DecodingResult {
            crate::whisper_caption::whisper::DecodingResult {
                tokens: self.tokens.cst_decode(),
                text: self.text.cst_decode(),
                avg_logprob: self.avg_logprob.cst_decode(),
                no_speech_prob: self.no_speech_prob.cst_decode(),
                temperature: self.temperature.cst_decode(),
                compression_ratio: self.compression_ratio.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<u32>> for *mut wire_cst_list_prim_u_32_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u32> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<crate::whisper_caption::whisper::Segment>> for *mut wire_cst_list_segment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::whisper_caption::whisper::Segment> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<crate::whisper_caption::whisper::Segment> for wire_cst_segment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::whisper_caption::whisper::Segment {
            crate::whisper_caption::whisper::Segment {
                start: self.start.cst_decode(),
                duration: self.duration.cst_decode(),
                dr: self.dr.cst_decode(),
                reasoning_duration: self.reasoning_duration.cst_decode(),
                reasoning_lang: self.reasoning_lang.cst_decode(),
                audio_duration: self.audio_duration.cst_decode(),
                status: self.status.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::whisper::WhisperClient> for wire_cst_whisper_client {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::whisper::WhisperClient {
            crate::api::whisper::WhisperClient {
                whisper_model: self.whisper_model.cst_decode(),
                whisper_config: self.whisper_config.cst_decode(),
                whisper_tokenizer: self.whisper_tokenizer.cst_decode(),
                is_multilingual: self.is_multilingual.cst_decode(),
                is_quantized: self.is_quantized.cst_decode(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_decoding_result {
        fn new_with_null_ptr() -> Self {
            Self {
                tokens: core::ptr::null_mut(),
                text: core::ptr::null_mut(),
                avg_logprob: Default::default(),
                no_speech_prob: Default::default(),
                temperature: Default::default(),
                compression_ratio: Default::default(),
            }
        }
    }
    impl Default for wire_cst_decoding_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_segment {
        fn new_with_null_ptr() -> Self {
            Self {
                start: Default::default(),
                duration: Default::default(),
                dr: Default::default(),
                reasoning_duration: core::ptr::null_mut(),
                reasoning_lang: core::ptr::null_mut(),
                audio_duration: core::ptr::null_mut(),
                status: Default::default(),
            }
        }
    }
    impl Default for wire_cst_segment {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_whisper_client {
        fn new_with_null_ptr() -> Self {
            Self {
                whisper_model: core::ptr::null_mut(),
                whisper_config: core::ptr::null_mut(),
                whisper_tokenizer: core::ptr::null_mut(),
                is_multilingual: Default::default(),
                is_quantized: Default::default(),
            }
        }
    }
    impl Default for wire_cst_whisper_client {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_wire__crate__api__whisper__cancel_cancellation_token(
        port_: i64,
        token_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__whisper__cancel_cancellation_token_impl(port_, token_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_wire__crate__api__text_util__count_duplicate_characters(
        port_: i64,
        input: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__text_util__count_duplicate_characters_impl(port_, input)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_wire__crate__api__whisper__create_cancellation_token(
        port_: i64,
    ) {
        wire__crate__api__whisper__create_cancellation_token_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_wire__crate__api__whisper__launch_caption(
        port_: i64,
        whisper_client: *mut wire_cst_whisper_client,
        stream_sink: *mut wire_cst_list_prim_u_8_strict,
        audio_device: *mut wire_cst_list_prim_u_8_strict,
        audio_device_is_input: *mut bool,
        audio_language: *mut wire_cst_list_prim_u_8_strict,
        cancel_token_id: *mut wire_cst_list_prim_u_8_strict,
        with_timestamps: *mut bool,
        verbose: *mut bool,
        try_with_cuda: *mut bool,
        whisper_max_audio_duration: *mut u32,
        inference_interval: *mut u64,
        whisper_default_max_decode_tokens: *mut usize,
        whisper_temperature: *mut f32,
        vad_model_path: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__whisper__launch_caption_impl(
            port_,
            whisper_client,
            stream_sink,
            audio_device,
            audio_device_is_input,
            audio_language,
            cancel_token_id,
            with_timestamps,
            verbose,
            try_with_cuda,
            whisper_max_audio_duration,
            inference_interval,
            whisper_default_max_decode_tokens,
            whisper_temperature,
            vad_model_path,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_wire__crate__api__whisper__whisper_client_new(
        port_: i64,
        whisper_model: *mut wire_cst_list_prim_u_8_strict,
        whisper_config: *mut wire_cst_list_prim_u_8_strict,
        whisper_tokenizer: *mut wire_cst_list_prim_u_8_loose,
        is_multilingual: bool,
        is_quantized: bool,
    ) {
        wire__crate__api__whisper__whisper_client_new_impl(
            port_,
            whisper_model,
            whisper_config,
            whisper_tokenizer,
            is_multilingual,
            is_quantized,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_box_autoadd_bool(value: bool) -> *mut bool {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_box_autoadd_f_32(value: f32) -> *mut f32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_box_autoadd_usize(value: usize) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_box_autoadd_whisper_client(
    ) -> *mut wire_cst_whisper_client {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_whisper_client::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_list_prim_u_32_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_32_strict {
        let ans = wire_cst_list_prim_u_32_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_list_prim_u_8_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_loose {
        let ans = wire_cst_list_prim_u_8_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_fl_caption_cst_new_list_segment(
        len: i32,
    ) -> *mut wire_cst_list_segment {
        let wrap = wire_cst_list_segment {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_segment>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_decoding_result {
        tokens: *mut wire_cst_list_prim_u_32_strict,
        text: *mut wire_cst_list_prim_u_8_strict,
        avg_logprob: f64,
        no_speech_prob: f64,
        temperature: f64,
        compression_ratio: f64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_32_strict {
        ptr: *mut u32,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_loose {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_segment {
        ptr: *mut wire_cst_segment,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_segment {
        start: f64,
        duration: f64,
        dr: wire_cst_decoding_result,
        reasoning_duration: *mut wire_cst_list_prim_u_8_strict,
        reasoning_lang: *mut wire_cst_list_prim_u_8_strict,
        audio_duration: *mut wire_cst_list_prim_u_8_strict,
        status: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_whisper_client {
        whisper_model: *mut wire_cst_list_prim_u_8_strict,
        whisper_config: *mut wire_cst_list_prim_u_8_strict,
        whisper_tokenizer: *mut wire_cst_list_prim_u_8_strict,
        is_multilingual: bool,
        is_quantized: bool,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
